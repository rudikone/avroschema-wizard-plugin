import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import io.gitlab.arturbosch.detekt.Detekt
import org.gradle.kotlin.dsl.withType
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    `kotlin-dsl`
    `java-gradle-plugin`
    alias(libs.plugins.pluginPublish)
    alias(libs.plugins.shadow)
    alias(libs.plugins.detekt)
    alias(libs.plugins.ktlint)
    alias(libs.plugins.versionCheck)
}

val implClass = property("IMPLEMENTATION_CLASS").toString()
val myPluginId = property("ID").toString()

gradlePlugin {
    plugins {
        create(property("ID").toString()) {
            id = property("ID").toString()
            implementationClass = implClass
            version = property("VERSION").toString()
            description = property("DESCRIPTION").toString()
            displayName = property("DISPLAY_NAME").toString()
            tags.set(listOf("avro", "schema-registry"))
        }
    }

    website.set(property("WEBSITE").toString())
    vcsUrl.set(property("VCS_URL").toString())
}

group = property("GROUP").toString()
version = property("VERSION").toString()

ktlint {
    debug.set(false)
    verbose.set(true)
    android.set(false)
    outputToConsole.set(true)
    ignoreFailures.set(false)
    enableExperimentalRules.set(true)
    filter {
        exclude("**/generated/**")
        include("**/kotlin/**")
    }
}

dependencies {
    implementation(kotlin("stdlib"))
    compileOnly(gradleApi())

    implementation(libs.schemaRegistryClient)
    implementation(libs.kafkaSchemaSerializer)

    testImplementation(libs.junitJupiterApi)
    testRuntimeOnly(libs.junitJupiterEngine)
    testImplementation(libs.junitJupiterParams)

    implementation(platform(libs.testcontainersBom))
    testImplementation(libs.testcontainers)
    testImplementation(libs.testcontainersKafka)
    testImplementation(libs.testcontainersJunitJupiter)

    testImplementation(kotlin("test"))
}

/*
 * You’re basically saying: “I’m writing Java code as if it were for Java X”
 * and also: “The compiled bytecode will run on Java X or newer.”
 */
java {
    /*
     * The source code (Java files) in this project is limited to the language features
     * available in Java X — meaning the compiler will only allow syntax and APIs
     * that exist in that Java version.
     * In other words, you can’t use language features introduced in Java X+1 or later.
     */
    sourceCompatibility = JavaVersion.VERSION_17
    /*
     * The compiled bytecode will target Java X — that is, it’s expected to run
     * on a JVM version X or newer.
     * The resulting .class files will be compatible with JVM version X+.
     * If you try to run them on an older JVM (e.g., X-1), you may get
     * an UnsupportedClassVersionError.
     */
    targetCompatibility = JavaVersion.VERSION_17
}

tasks {

    /*
     * Selects all Kotlin compilation tasks in the project (i.e., tasks of type KotlinCompile)
     * and configures their compilation parameters:
     * - sets the Kotlin compiler option that defines the target JVM bytecode version ("X")
     *   (for example, if set to "1.8", the generated bytecode will be compatible with Java 8 and later)
     */
    withType<KotlinCompile>().configureEach {
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_17)
        }
    }

    register("reformatAll") {
        description = "Reformat all the Kotlin Code"
        dependsOn("ktlintFormat")
    }

    withType<Detekt> {
        reports {
            html.required.set(true)
            html.outputLocation.set(file("build/reports/detekt.html"))
        }
    }

    /*
     * It is needed to ensure that tests always verify the current version of the plugin.
     * See io.github.rudikone.avroschemawizardplugin.RegisterTaskTest and io.github.rudikone.avroschemawizardplugin.testutils.Plugin
     */
    test {
        dependsOn(publishToMavenLocal)
        useJUnitPlatform {
            environment.putIfAbsent("avroschema-wizard-plugin-version", project.version)
        }
    }

    named("shadowJar", ShadowJar::class) {
        // Basic archive settings
        archiveBaseName.set(project.name)
        archiveClassifier.set("")
        archiveVersion.set("")

        // Relocation of critical dependencies
        relocate("io.confluent", "avrowizard.io.confluent")
        relocate("org.apache.kafka", "avrowizard.org.apache.kafka")
        relocate("com.fasterxml.jackson", "avrowizard.jackson")
        relocate("org.apache.avro", "avrowizard.org.apache.avro")

        // Exclude unnecessary files
        exclude("**/module-info.class")
        exclude("META-INF/maven/**")
        exclude("META-INF/*.SF")
        exclude("META-INF/*.DSA")
        exclude("META-INF/*.RSA")
        exclude("**/LICENSE")
        exclude("**/NOTICE")
        exclude("**/*.txt")

        // Merge service files
        // This is critical for proper Kafka serializer functionality
        mergeServiceFiles()

        // Minimization
        minimize {
            // Exclude critical dependencies from minimization
            exclude(dependency("com.google.guava:.*:.*"))
            exclude(dependency("io.confluent:.*:.*"))
            exclude(dependency("org.apache.kafka:.*:.*"))
            exclude(dependency("com.fasterxml.jackson:.*:.*"))
            exclude(dependency("org.apache.avro:.*:.*"))
            exclude(dependency("org.gradle:.*:.*"))
        }

        // Manifest configuration
        manifest {
            attributes["Main-Class"] = implClass
            attributes["Implementation-Title"] = myPluginId
            attributes["Implementation-Version"] = project.version
            attributes["Built-Gradle"] = gradle.gradleVersion
        }

        // Dependency filtering (filters project-declared dependencies for the final fat JAR)
        dependencies {
            // Exclude dependencies already provided by Gradle or runtime
            exclude(dependency("org.jetbrains.kotlin:.*:.*"))
            exclude(dependency("org.slf4j:.*:.*"))
            exclude(dependency("org.apache.logging.log4j:.*:.*"))
            exclude(dependency("org.testcontainers:.*:.*"))
        }

        isZip64 = true
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    register("preMerge") {
        description = "Runs all the tests/verification tasks"
        dependsOn("check")
        dependsOn("validatePlugins")
    }

    register("setupPluginUploadFromEnvironment") {
        doLast {
            val key = System.getenv("GRADLE_PUBLISH_KEY")
            val secret = System.getenv("GRADLE_PUBLISH_SECRET")

            if (key == null || secret == null) {
                throw GradleException("gradlePublishKey and/or gradlePublishSecret are not defined environment variables")
            }

            System.setProperty("gradle.publish.key", key)
            System.setProperty("gradle.publish.secret", secret)
        }
    }

    withType<DependencyUpdatesTask> {
        rejectVersionIf {
            candidate.version.isNonStable()
        }
    }

    wrapper {
        distributionType = Wrapper.DistributionType.ALL
    }
}

fun String.isNonStable() = "^[0-9,.v-]+(-r)?$".toRegex().matches(this).not()
